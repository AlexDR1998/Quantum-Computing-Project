#!/usr/bin/env python#-*- coding: utf-8 -*-import numpy as npimport matplotlib.pyplot as pltfrom quantum_classes import(	hadamard)from perceptron_fct import(	mat_teacher_bin)__author__ = "Jean-Christophe Gomez-Lavocat - UCSD"__copyright__ = "Copyright 2009, The Cogent Project"__credits__ = ["Jean-Chrsitophe Lavocat", "David Meyer"]__license__ = "GPL"__version__ = "1.0.2"__maintainer__ = "Jice Lavocat"__email__ = "jice@lavocat.name"__status__ = "Development"n=6N=2**n# Generation de la query matrix de l'oracle# Query Matrix Creation (see : http://xxx.lanl.gov/abs/quant-ph/0309059 )teachers=mat_teacher_bin(N,1)print "The teachers' matrix is :"print teachers	# Generation du vecteur Teacher (la seul donnée du problème)# Teacher's vector / Only data availablewt=5  # Quel est le teacher ? A donner en representation decimale  (|010> = 2)# Which teacher do we choose? Give it as a decimal numberteacher=teachers[wt]	print "The teacher's answers are : "	print teacher	# Generation des matrices Dx binaires# Dx Matrices CreationDx=np.diag(teacher)#print Dx# Generation de la matrice A# Generalized Grover's Matrix CreationHn=hadamard(n)Av=np.ones((1,N))Av[0][0]=-1"""Av[0][1]=-1Av[0][2]=-1Av[0][(N-1)/2.]=-1Av[0][N-3]=-1Av[0][N-2]=-1"""Av[0][N-1]=-1A=np.diag(Av[0])A=np.dot(Hn,np.dot(A,Hn))#print A#The matrix A has constant diagonal and outdiagonal elements#Generation of the initial vectorw=1/np.sqrt(N) * np.ones((N,1))#Uncomment to see the evolution of the probability distribution'''from pylab import *import timeion()tstart = time.time()               # for profilingx = arange(0,N)            # x-arrayplot(x,w.conjugate()*w)a=raw_input("Print enter to see the animation :-s")#line, = bar(x,w)for i in arange(1,N):		clf()	w=dot(A,dot(Dx,w))	#line.set_ydata(w)	plot(x,w.conjugate()*w)  # update the data	draw()                         # redraw the canvas	print i	print w.conjugate()*w    #norm vecteur au carré	a=raw_input()print 'FPS:' , 200/(time.time()-tstart)'''#Uncomment to see the evolution of the probability of the target teacher's weight when the student is learningbound=50x = np.arange(0,bound)            # x-arrayy=1/np.sqrt(N) * np.ones((bound,N),complex)for i in range(1,bound):	y[i]=-np.dot(A,np.dot(Dx,y[i-1]))	#print y[:,wt]tit="$|w_s|^2$ for n="+str(n)+" qubits (N="+str(N)+") and $w_T=|$"+str(np.binary_repr(wt, width=n))+">"plt.plot(x,(y[:,wt]).conjugate()*y[:,wt],'r')#plt.plot(x,(y[:,wt-1]).conjugate()*y[:,wt-1],'b')plt.title(tit)plt.xlabel('Number of iteration of A.Dx.w')plt.ylabel('$|w_s|^2$ ',rotation='horizontal',va='top')plt.show()